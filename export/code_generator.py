"""
Генератор OpenCV коду з фігур
"""
from constants import COLOR_MAP


class CodeGenerator:
    """Клас для генерації OpenCV Python коду"""
    
    @staticmethod
    def generate_opencv_code(shapes, origin_mode='editor', canvas_width=None, canvas_height=None, groups=None):
        """
        Генерація структурованого OpenCV коду у вигляді класу
        
        Args:
            shapes: список фігур
            origin_mode: 'editor' або 'center' - система координат
            canvas_width: ширина полотна (для center mode)
            canvas_height: висота полотна (для center mode)
            groups: список груп (ShapeGroup objects) - якщо None, експортує все одним класом
        
        Returns:
            str: Python код з OpenCV
        """
        # Якщо є групи - генеруємо окремі класи
        if groups and len(groups) > 0:
            return CodeGenerator._generate_with_groups(
                shapes, groups, origin_mode, canvas_width, canvas_height
            )
        
        # Інакше - генеруємо один клас як раніше
        return CodeGenerator._generate_single_class(
            shapes, origin_mode, canvas_width, canvas_height
        )
    
    @staticmethod
    def _generate_with_groups(shapes, groups, origin_mode, canvas_width, canvas_height):
        """
        Генерація коду з окремими класами для кожної групи
        """
        lines = []
        
        # Імпорти
        lines.append('"""')
        lines.append('OpenCV Drawing Overlay - Auto-generated by OpenCV HUD Editor')
        lines.append('"""')
        lines.append('import cv2')
        lines.append('import numpy as np')
        
        # Перевіряємо чи потрібен math для будь-якої групи
        needs_math = CodeGenerator._check_needs_math(shapes)
        if needs_math:
            lines.append('import math')
        
        lines.append('')
        lines.append('')
        
        # Визначаємо offset
        if origin_mode == 'center' and canvas_width is not None and canvas_height is not None:
            offset_x = canvas_width // 2
            offset_y = canvas_height // 2
        else:
            offset_x = 0
            offset_y = 0
        
        # Збираємо фігури що не в жодній групі
        grouped_indices = set()
        for group in groups:
            grouped_indices.update(group.shape_indices)
        
        ungrouped_indices = set(range(len(shapes))) - grouped_indices
        ungrouped_shapes = [shapes[i] for i in sorted(ungrouped_indices)]
        
        # Генеруємо допоміжні методи (якщо потрібні)
        has_dashed = CodeGenerator._check_has_line_style(shapes, 'dashed')
        has_dotted = CodeGenerator._check_has_line_style(shapes, 'dotted')
        has_curves = CodeGenerator._check_has_curves(shapes)
        
        if has_dashed or has_dotted or has_curves:
            lines.append('# === Допоміжні функції ===')
            lines.append('')
            if has_dashed:
                lines.extend(CodeGenerator._generate_dashed_line_function())
            if has_dotted:
                lines.extend(CodeGenerator._generate_dotted_line_function())
            if has_curves:
                lines.extend(CodeGenerator._generate_bezier_curve_function())
            lines.append('')
            lines.append('')
        
        # Генеруємо клас для кожної групи
        for group in groups:
            group_shapes = [shapes[i] for i in sorted(group.shape_indices) if i < len(shapes)]
            if group_shapes:
                lines.extend(
                    CodeGenerator._generate_class_for_shapes(
                        group.name, group_shapes, origin_mode, offset_x, offset_y
                    )
                )
                lines.append('')
                lines.append('')
        
        # Генеруємо клас для незгрупованих фігур (якщо є)
        if ungrouped_shapes:
            lines.extend(
                CodeGenerator._generate_class_for_shapes(
                    'UngroupedShapes', ungrouped_shapes, origin_mode, offset_x, offset_y
                )
            )
            lines.append('')
            lines.append('')
        
        # Генеруємо приклад використання
        lines.extend(CodeGenerator._generate_usage_example_for_groups(groups, bool(ungrouped_shapes)))
        
        return '\n'.join(lines)
    
    @staticmethod
    def _generate_single_class(shapes, origin_mode, canvas_width, canvas_height):
        """
        Генерація коду з одним класом (старий метод)
        """
        
        # Перевіряємо чи потрібен math
        needs_math = CodeGenerator._check_needs_math(shapes)
        has_dashed = CodeGenerator._check_has_line_style(shapes, 'dashed')
        has_dotted = CodeGenerator._check_has_line_style(shapes, 'dotted')
        has_curves = CodeGenerator._check_has_curves(shapes)
        
        if needs_math:
            lines.append('import math')
        
        lines.append('')
        lines.append('')
        
        # Збираємо унікальні кольори
        unique_colors, color_name_map = CodeGenerator._collect_colors(shapes)
        
        # Визначаємо offset
        if origin_mode == 'center' and canvas_width is not None and canvas_height is not None:
            offset_x = canvas_width // 2
            offset_y = canvas_height // 2
        else:
            offset_x = 0
            offset_y = 0
        
        # Початок класу
        lines.extend(CodeGenerator._generate_class_header(
            origin_mode, offset_x, offset_y, has_dashed, has_dotted, has_curves, len(shapes)
        ))
        
        # Кольори
        if unique_colors:
            lines.append('        # Кольори (BGR формат)')
            lines.append('        self.colors = {')
            for key, color_bgr in unique_colors.items():
                color_name = color_name_map[key]
                b, g, r = color_bgr
                lines.append(f"            '{color_name}': ({b}, {g}, {r}),")
            lines.append('        }')
        
        lines.append('    ')
        
        # Допоміжні методи
        if has_dashed:
            lines.extend(CodeGenerator._generate_dashed_line_method())
        if has_dotted:
            lines.extend(CodeGenerator._generate_dotted_line_method())
        if has_curves:
            lines.extend(CodeGenerator._generate_bezier_curve_method())
        
        # Основний метод малювання
        lines.extend(CodeGenerator._generate_draw_method_header())
        
        # Генеруємо код для кожної фігури
        for shape in shapes:
            lines.extend(CodeGenerator._generate_shape_code(
                shape, color_name_map, offset_x, offset_y
            ))
        
        lines.append('        ')
        lines.append('        return frame')
        lines.append('')
        lines.append('')
        
        # Приклад використання
        lines.extend(CodeGenerator._generate_usage_example())
        
        return '\n'.join(lines)
    
    @staticmethod
    def _check_needs_math(shapes):
        """Перевірити чи потрібен math"""
        for shape in shapes:
            line_style = getattr(shape, 'line_style', 'solid')
            if line_style in ['dashed', 'dotted']:
                return True
            if shape.kind == 'arrow' and line_style != 'solid':
                return True
            if shape.kind == 'curve':
                return True
        return False
    
    @staticmethod
    def _check_has_line_style(shapes, style):
        """Перевірити чи є фігури з певним стилем лінії"""
        for shape in shapes:
            if getattr(shape, 'line_style', 'solid') == style:
                return True
        return False
    
    @staticmethod
    def _check_has_curves(shapes):
        """Перевірити чи є криві"""
        for shape in shapes:
            if shape.kind == 'curve':
                return True
        return False
    
    @staticmethod
    def _collect_colors(shapes):
        """Зібрати унікальні кольори"""
        unique_colors = {}
        color_name_map = {}
        color_counter = {}
        
        for shape in shapes:
            color_bgr = shape.color_bgr
            style = shape.style
            key = (color_bgr, style)
            
            if key not in color_name_map:
                color_name = CodeGenerator._get_color_name(color_bgr, style, color_counter)
                color_name_map[key] = color_name
                unique_colors[key] = color_bgr
        
        return unique_colors, color_name_map
    
    @staticmethod
    def _get_color_name(color_bgr, style, color_counter):
        """Отримати назву кольору"""
        if color_bgr in COLOR_MAP:
            base_name = COLOR_MAP[color_bgr]
        else:
            b, g, r = color_bgr
            base_name = f"color_{r}_{g}_{b}"
        
        if style != 'default':
            color_name = f"{base_name}_{style}"
        else:
            color_name = base_name
        
        if color_name in color_counter:
            color_counter[color_name] += 1
            color_name = f"{color_name}_{color_counter[color_name]}"
        else:
            color_counter[color_name] = 0
        
        return color_name
    
    @staticmethod
    def _generate_class_header(origin_mode, offset_x, offset_y, has_dashed, has_dotted, has_curves, num_shapes):
        """Генерувати заголовок класу"""
        lines = []
        lines.append('class DrawingOverlay:')
        lines.append('    """')
        lines.append('    Клас для малювання overlay графіки на кадрі')
        lines.append('    ')
        if origin_mode == 'center':
            lines.append(f'    Система координат: відносно центру (offset: {offset_x}, {offset_y})')
        else:
            lines.append('    Система координат: як у редакторі (0,0 в лівому верхньому куті)')
        lines.append('    ')
        
        styles_info = []
        if has_dashed:
            styles_info.append('dashed lines')
        if has_dotted:
            styles_info.append('dotted lines')
        if has_curves:
            styles_info.append('bezier curves')
        if styles_info:
            lines.append(f"    Використані стилі: {', '.join(styles_info)}")
        lines.append(f'    Кількість фігур: {num_shapes}')
        lines.append('    """')
        lines.append('    ')
        lines.append('    def __init__(self):')
        lines.append('        """Ініціалізація кольорів та констант"""')
        return lines
    
    @staticmethod
    def _generate_dashed_line_method():
        """Генерувати метод для пунктирних ліній"""
        return [
            '    @staticmethod',
            '    def draw_dashed_line(frame, pt1, pt2, color, thickness=1, dash_length=10):',
            '        """Малювання пунктирної лінії"""',
            '        dist = math.hypot(pt2[0] - pt1[0], pt2[1] - pt1[1])',
            '        if dist < 1:',
            '            return',
            '        dashes = int(dist / dash_length)',
            '        for i in range(dashes):',
            '            if i % 2 == 0:',
            '                start = (',
            '                    int(pt1[0] + (pt2[0] - pt1[0]) * i / dashes),',
            '                    int(pt1[1] + (pt2[1] - pt1[1]) * i / dashes)',
            '                )',
            '                end = (',
            '                    int(pt1[0] + (pt2[0] - pt1[0]) * (i + 0.5) / dashes),',
            '                    int(pt1[1] + (pt2[1] - pt1[1]) * (i + 0.5) / dashes)',
            '                )',
            '                cv2.line(frame, start, end, color, thickness, cv2.LINE_AA)',
            '    '
        ]
    
    @staticmethod
    def _generate_dotted_line_method():
        """Генерувати метод для точкових ліній"""
        return [
            '    @staticmethod',
            '    def draw_dotted_line(frame, pt1, pt2, color, thickness=1, dot_length=5):',
            '        """Малювання точкової лінії"""',
            '        dist = math.hypot(pt2[0] - pt1[0], pt2[1] - pt1[1])',
            '        if dist < 1:',
            '            return',
            '        dots = int(dist / dot_length)',
            '        for i in range(dots):',
            '            if i % 2 == 0:',
            '                pt = (',
            '                    int(pt1[0] + (pt2[0] - pt1[0]) * i / dots),',
            '                    int(pt1[1] + (pt2[1] - pt1[1]) * i / dots)',
            '                )',
            '                cv2.circle(frame, pt, max(1, thickness), color, -1, cv2.LINE_AA)',
            '    '
        ]
    
    @staticmethod
    def _generate_bezier_curve_method():
        """Генерувати метод для кривих Безьє"""
        return [
            '    @staticmethod',
            '    def draw_bezier_curve(frame, x1, y1, x2, y2, cx, cy, color, thickness=1, steps=20):',
            '        """Малювання квадратичної кривої Безьє"""',
            '        points = []',
            '        for i in range(steps + 1):',
            '            t = i / steps',
            '            # Квадратична крива Безьє: B(t) = (1-t)²P0 + 2(1-t)tP1 + t²P2',
            '            bx = int((1 - t) ** 2 * x1 + 2 * (1 - t) * t * cx + t ** 2 * x2)',
            '            by = int((1 - t) ** 2 * y1 + 2 * (1 - t) * t * cy + t ** 2 * y2)',
            '            points.append([bx, by])',
            '        # Малюємо криву як polyline',
            '        pts = np.array([points], dtype=np.int32)',
            '        cv2.polylines(frame, pts, False, color, thickness, cv2.LINE_AA)',
            '    '
        ]
    
    @staticmethod
    def _generate_draw_method_header():
        """Генерувати заголовок методу draw"""
        return [
            '    def draw(self, frame):',
            '        """',
            '        Намалювати всі фігури на кадрі',
            '        ',
            '        Args:',
            '            frame: np.ndarray (H, W, 3) BGR',
            '        ',
            '        Returns:',
            '            frame: np.ndarray з намальованими фігурами',
            '        """'
        ]
    
    @staticmethod
    def _generate_shape_code(shape, color_name_map, offset_x, offset_y):
        """Генерувати код для однієї фігури"""
        lines = []
        color_bgr = shape.color_bgr
        style = shape.style
        key = (color_bgr, style)
        color_name = color_name_map[key]
        t = shape.thickness
        line_style = getattr(shape, 'line_style', 'solid')
        filled = getattr(shape, 'filled', False)
        thickness_param = -1 if filled else t
        
        # Коментар
        comments = []
        if shape.style != 'default':
            comments.append(f'style: {shape.style}')
        if line_style != 'solid':
            comments.append(f'line: {line_style}')
        if filled:
            comments.append('filled')
        comment = f'  # {", ".join(comments)}' if comments else ''
        
        if shape.kind == 'line':
            c = shape.coords
            x1 = int(c['x1']) - offset_x
            y1 = int(c['y1']) - offset_y
            x2 = int(c['x2']) - offset_x
            y2 = int(c['y2']) - offset_y
            
            if line_style == 'dashed':
                dash_len = getattr(shape, 'dash_length', 10)
                lines.append(f"        draw_dashed_line(frame, ({x1}, {y1}), ({x2}, {y2}), self.colors['{color_name}'], {t}, dash_length={dash_len}){comment}")
            elif line_style == 'dotted':
                dot_len = getattr(shape, 'dot_length', 5)
                lines.append(f"        draw_dotted_line(frame, ({x1}, {y1}), ({x2}, {y2}), self.colors['{color_name}'], {t}, dot_length={dot_len}){comment}")
            else:
                lines.append(f"        cv2.line(frame, ({x1}, {y1}), ({x2}, {y2}), self.colors['{color_name}'], {t}, cv2.LINE_AA){comment}")
        
        elif shape.kind == 'arrow':
            c = shape.coords
            x1 = int(c['x1']) - offset_x
            y1 = int(c['y1']) - offset_y
            x2 = int(c['x2']) - offset_x
            y2 = int(c['y2']) - offset_y
            
            if line_style == 'solid':
                lines.append(f"        cv2.arrowedLine(frame, ({x1}, {y1}), ({x2}, {y2}), self.colors['{color_name}'], {t}, cv2.LINE_AA, tipLength=0.3){comment}")
            else:
                # Для пунктирних стрілок малюємо лінію + трикутник
                if line_style == 'dashed':
                    dash_len = getattr(shape, 'dash_length', 10)
                    lines.append(f"        draw_dashed_line(frame, ({x1}, {y1}), ({x2}, {y2}), self.colors['{color_name}'], {t}, dash_length={dash_len}){comment}")
                else:
                    dot_len = getattr(shape, 'dot_length', 5)
                    lines.append(f"        draw_dotted_line(frame, ({x1}, {y1}), ({x2}, {y2}), self.colors['{color_name}'], {t}, dot_length={dot_len}){comment}")
                # Трикутник стрілки
                lines.append(f"        dx, dy = {x2} - {x1}, {y2} - {y1}")
                lines.append(f"        length = math.hypot(dx, dy)")
                lines.append(f"        if length > 0:")
                lines.append(f"            dx, dy = dx / length, dy / length")
                lines.append(f"            arrow_size = min(20, length / 3)")
                lines.append(f"            pts = np.array([[")
                lines.append(f"                [{x2}, {y2}],")
                lines.append(f"                [int({x2} - arrow_size * dx + arrow_size * 0.3 * dy), int({y2} - arrow_size * dy - arrow_size * 0.3 * dx)],")
                lines.append(f"                [int({x2} - arrow_size * dx - arrow_size * 0.3 * dy), int({y2} - arrow_size * dy + arrow_size * 0.3 * dx)]")
                lines.append(f"            ]], dtype=np.int32)")
                lines.append(f"            cv2.fillPoly(frame, pts, self.colors['{color_name}'], cv2.LINE_AA)")
        
        elif shape.kind == 'curve':
            c = shape.coords
            x1 = int(c['x1']) - offset_x
            y1 = int(c['y1']) - offset_y
            x2 = int(c['x2']) - offset_x
            y2 = int(c['y2']) - offset_y
            cx = int(c['cx']) - offset_x
            cy = int(c['cy']) - offset_y
            lines.append(f"        draw_bezier_curve(frame, {x1}, {y1}, {x2}, {y2}, {cx}, {cy}, self.colors['{color_name}'], {t}){comment}")
        
        elif shape.kind == 'circle':
            c = shape.coords
            cx = int(c['cx']) - offset_x
            cy = int(c['cy']) - offset_y
            r = int(c['r'])
            lines.append(f"        cv2.circle(frame, ({cx}, {cy}), {r}, self.colors['{color_name}'], {thickness_param}, cv2.LINE_AA){comment}")
        
        elif shape.kind == 'ellipse':
            c = shape.coords
            cx = int(c['cx']) - offset_x
            cy = int(c['cy']) - offset_y
            rx = int(c['rx'])
            ry = int(c['ry'])
            angle = int(c.get('angle', 0))
            lines.append(f"        cv2.ellipse(frame, ({cx}, {cy}), ({rx}, {ry}), {angle}, 0, 360, self.colors['{color_name}'], {thickness_param}, cv2.LINE_AA){comment}")
        
        elif shape.kind == 'rectangle':
            c = shape.coords
            x1 = int(c['x1']) - offset_x
            y1 = int(c['y1']) - offset_y
            x2 = int(c['x2']) - offset_x
            y2 = int(c['y2']) - offset_y
            lines.append(f"        cv2.rectangle(frame, ({x1}, {y1}), ({x2}, {y2}), self.colors['{color_name}'], {thickness_param}, cv2.LINE_AA){comment}")
        
        elif shape.kind == 'polygon':
            c = shape.coords
            if 'points' in c:
                pts = [(int(x) - offset_x, int(y) - offset_y) for x, y in c['points']]
                pts_str = ', '.join([f'[{x}, {y}]' for x, y in pts])
                lines.append(f"        pts = np.array([[{pts_str}]], dtype=np.int32)")
                if filled:
                    lines.append(f"        cv2.fillPoly(frame, pts, self.colors['{color_name}'], cv2.LINE_AA){comment}")
                else:
                    lines.append(f"        cv2.polylines(frame, pts, True, self.colors['{color_name}'], {t}, cv2.LINE_AA){comment}")
        
        elif shape.kind == 'point':
            c = shape.coords
            x = int(c['x']) - offset_x
            y = int(c['y']) - offset_y
            point_size = max(3, t * 2)
            lines.append(f"        cv2.circle(frame, ({x}, {y}), {point_size}, self.colors['{color_name}'], -1, cv2.LINE_AA){comment}")
        
        elif shape.kind == 'text':
            c = shape.coords
            x = int(c['x']) - offset_x
            y = int(c['y']) - offset_y
            text = getattr(shape, 'text', '')
            font_scale = getattr(shape, 'font_scale', 1.0)
            lines.append(f"        cv2.putText(frame, '{text}', ({x}, {y}), cv2.FONT_HERSHEY_SIMPLEX, {font_scale}, self.colors['{color_name}'], {t}, cv2.LINE_AA){comment}")
        
        return lines
    
    @staticmethod
    def _generate_usage_example():
        """Генерувати приклад використання"""
        return [
            '# Приклад використання:',
            "if __name__ == '__main__':",
            '    # Створюємо overlay',
            '    overlay = DrawingOverlay()',
            '    ',
            '    # Читаємо або створюємо кадр',
            '    frame = np.zeros((720, 1280, 3), dtype=np.uint8)  # Чорний кадр',
            '    # або завантажте з відео/камери:',
            '    # cap = cv2.VideoCapture(0)',
            '    # ret, frame = cap.read()',
            '    ',
            '    # Малюємо overlay',
            '    frame = overlay.draw(frame)',
            '    ',
            '    # Показуємо результат',
            "    cv2.imshow('Overlay', frame)",
            '    cv2.waitKey(0)',
            '    cv2.destroyAllWindows()'
        ]
    
    @staticmethod
    def _generate_usage_example_for_groups(groups, has_ungrouped):
        """Генерувати приклад використання для груп"""
        lines = [
            '# Приклад використання:',
            "if __name__ == '__main__':",
            '    # Читаємо або створюємо кадр',
            '    frame = np.zeros((720, 1280, 3), dtype=np.uint8)  # Чорний кадр',
            '    # або завантажте з відео/камери:',
            '    # cap = cv2.VideoCapture(0)',
            '    # ret, frame = cap.read()',
            '    ',
            '    # Створюємо екземпляри груп',
        ]
        
        for group in groups:
            class_name = CodeGenerator._sanitize_class_name(group.name)
            var_name = CodeGenerator._sanitize_var_name(group.name)
            lines.append(f'    {var_name} = {class_name}()')
        
        if has_ungrouped:
            lines.append('    ungrouped = UngroupedShapes()')
        
        lines.extend([
            '    ',
            '    # Малюємо всі групи',
        ])
        
        for group in groups:
            var_name = CodeGenerator._sanitize_var_name(group.name)
            lines.append(f'    frame = {var_name}.draw(frame)')
        
        if has_ungrouped:
            lines.append('    frame = ungrouped.draw(frame)')
        
        lines.extend([
            '    ',
            '    # Показуємо результат',
            "    cv2.imshow('Overlay', frame)",
            '    cv2.waitKey(0)',
            '    cv2.destroyAllWindows()'
        ])
        
        return lines
    
    @staticmethod
    def _sanitize_class_name(name):
        """Перетворити назву на коректну назву класу"""
        # Видалити недопустимі символи
        import re
        # Замінюємо пробіли та спецсимволи на підкреслення
        name = re.sub(r'[^\w]+', '_', name)
        # Видаляємо підкреслення на початку/кінці
        name = name.strip('_')
        # Робимо першу літеру великою
        if name and name[0].isdigit():
            name = 'Shape_' + name
        return name.title().replace('_', '')
    
    @staticmethod
    def _sanitize_var_name(name):
        """Перетворити назву на коректну назву змінної"""
        import re
        name = re.sub(r'[^\w]+', '_', name)
        name = name.strip('_').lower()
        if name and name[0].isdigit():
            name = 'shape_' + name
        return name
    
    @staticmethod
    def _generate_class_for_shapes(class_name, shapes, origin_mode, offset_x, offset_y):
        """Генерувати клас для групи фігур"""
        lines = []
        
        # Sanitize class name
        class_name = CodeGenerator._sanitize_class_name(class_name)
        
        # Перевіряємо що потрібно
        has_dashed = CodeGenerator._check_has_line_style(shapes, 'dashed')
        has_dotted = CodeGenerator._check_has_line_style(shapes, 'dotted')
        has_curves = CodeGenerator._check_has_curves(shapes)
        
        # Збираємо кольори
        unique_colors, color_name_map = CodeGenerator._collect_colors(shapes)
        
        # Заголовок класу
        lines.append(f'class {class_name}:')
        lines.append('    """')
        lines.append(f'    Клас для малювання групи: {class_name}')
        if origin_mode == 'center':
            lines.append(f'    Система координат: відносно центру (offset: {offset_x}, {offset_y})')
        else:
            lines.append('    Система координат: як у редакторі (0,0 в лівому верхньому куті)')
        lines.append(f'    Кількість фігур: {len(shapes)}')
        lines.append('    """')
        lines.append('    ')
        lines.append('    def __init__(self):')
        lines.append('        """Ініціалізація кольорів"""')
        
        # Кольори
        if unique_colors:
            lines.append('        self.colors = {')
            for key, color_bgr in unique_colors.items():
                color_name = color_name_map[key]
                b, g, r = color_bgr
                lines.append(f"            '{color_name}': ({b}, {g}, {r}),")
            lines.append('        }')
        
        lines.append('    ')
        lines.append('    def draw(self, frame):')
        lines.append('        """Намалювати фігури на кадрі"""')
        
        # Генеруємо код для кожної фігури
        for shape in shapes:
            shape_lines = CodeGenerator._generate_shape_code(
                shape, color_name_map, offset_x, offset_y
            )
            lines.extend(shape_lines)
        
        lines.append('        return frame')
        
        return lines
    
    @staticmethod
    def _generate_dashed_line_function():
        """Генерувати функцію для пунктирних ліній (глобальна)"""
        return [
            'def draw_dashed_line(frame, pt1, pt2, color, thickness=1, dash_length=10):',
            '    """Малювання пунктирної лінії"""',
            '    dist = math.hypot(pt2[0] - pt1[0], pt2[1] - pt1[1])',
            '    if dist < 1:',
            '        return',
            '    dashes = int(dist / dash_length)',
            '    for i in range(dashes):',
            '        if i % 2 == 0:',
            '            start = (',
            '                int(pt1[0] + (pt2[0] - pt1[0]) * i / dashes),',
            '                int(pt1[1] + (pt2[1] - pt1[1]) * i / dashes)',
            '            )',
            '            end = (',
            '                int(pt1[0] + (pt2[0] - pt1[0]) * (i + 0.5) / dashes),',
            '                int(pt1[1] + (pt2[1] - pt1[1]) * (i + 0.5) / dashes)',
            '            )',
            '            cv2.line(frame, start, end, color, thickness, cv2.LINE_AA)',
            ''
        ]
    
    @staticmethod
    def _generate_dotted_line_function():
        """Генерувати функцію для точкових ліній (глобальна)"""
        return [
            'def draw_dotted_line(frame, pt1, pt2, color, thickness=1, dot_length=5):',
            '    """Малювання точкової лінії"""',
            '    dist = math.hypot(pt2[0] - pt1[0], pt2[1] - pt1[1])',
            '    if dist < 1:',
            '        return',
            '    dots = int(dist / dot_length)',
            '    for i in range(dots):',
            '        if i % 2 == 0:',
            '            pt = (',
            '                int(pt1[0] + (pt2[0] - pt1[0]) * i / dots),',
            '                int(pt1[1] + (pt2[1] - pt1[1]) * i / dots)',
            '            )',
            '            cv2.circle(frame, pt, max(1, thickness), color, -1, cv2.LINE_AA)',
            ''
        ]
    
    @staticmethod
    def _generate_bezier_curve_function():
        """Генерувати функцію для кривих Безьє (глобальна)"""
        return [
            'def draw_bezier_curve(frame, x1, y1, x2, y2, cx, cy, color, thickness=1, steps=20):',
            '    """Малювання квадратичної кривої Безьє"""',
            '    points = []',
            '    for i in range(steps + 1):',
            '        t = i / steps',
            '        bx = int((1 - t) ** 2 * x1 + 2 * (1 - t) * t * cx + t ** 2 * x2)',
            '        by = int((1 - t) ** 2 * y1 + 2 * (1 - t) * t * cy + t ** 2 * y2)',
            '        points.append([bx, by])',
            '    pts = np.array([points], dtype=np.int32)',
            '    cv2.polylines(frame, pts, False, color, thickness, cv2.LINE_AA)',
            ''
        ]

