"""
Генератор коду OpenCV для експорту фігур
"""
import math


class CodeGenerator:
    """Клас для генерації OpenCV коду з фігур"""
    
    @staticmethod
    def generate_opencv_code(shapes, origin_mode='editor', canvas_width=None, canvas_height=None, groups=None):
        """
        Генерувати OpenCV код з фігур
        
        Args:
            shapes: список фігур Shape
            origin_mode: режим координат ('editor' - як у редакторі, 'opencv' - як у OpenCV)
            canvas_width: ширина полотна
            canvas_height: висота полотна
            groups: список груп ShapeGroup (опціонально)
        
        Returns:
            str: згенерований Python код
        """
        lines = []
        
        # Заголовок
        lines.append('"""')
        lines.append('OpenCV Drawing Overlay - Auto-generated by OpenCV HUD Editor')
        lines.append('"""')
        lines.append('import cv2')
        lines.append('import numpy as np')
        lines.append('import math')
        lines.append('')
        lines.append('')
        lines.append('# === Допоміжні функції ===')
        lines.append('')
        
        # Допоміжні функції
        lines.append('def draw_dashed_line(frame, pt1, pt2, color, thickness=1, dash_length=10):')
        lines.append('    """Малювання пунктирної лінії"""')
        lines.append('    x1, y1 = pt1')
        lines.append('    x2, y2 = pt2')
        lines.append('    ')
        lines.append('    dx = x2 - x1')
        lines.append('    dy = y2 - y1')
        lines.append('    length = math.sqrt(dx * dx + dy * dy)')
        lines.append('    ')
        lines.append('    if length == 0:')
        lines.append('        return')
        lines.append('    ')
        lines.append('    dx /= length')
        lines.append('    dy /= length')
        lines.append('    ')
        lines.append('    current_length = 0')
        lines.append('    draw = True')
        lines.append('    ')
        lines.append('    while current_length < length:')
        lines.append('        start_x = int(x1 + dx * current_length)')
        lines.append('        start_y = int(y1 + dy * current_length)')
        lines.append('        ')
        lines.append('        current_length += dash_length')
        lines.append('        if current_length > length:')
        lines.append('            current_length = length')
        lines.append('        ')
        lines.append('        end_x = int(x1 + dx * current_length)')
        lines.append('        end_y = int(y1 + dy * current_length)')
        lines.append('        ')
        lines.append('        if draw:')
        lines.append('            cv2.line(frame, (start_x, start_y), (end_x, end_y), color, thickness, cv2.LINE_AA)')
        lines.append('        ')
        lines.append('        draw = not draw')
        lines.append('')
        lines.append('def draw_dotted_line(frame, pt1, pt2, color, thickness=1, dot_spacing=5):')
        lines.append('    """Малювання точкової лінії"""')
        lines.append('    x1, y1 = pt1')
        lines.append('    x2, y2 = pt2')
        lines.append('    ')
        lines.append('    dx = x2 - x1')
        lines.append('    dy = y2 - y1')
        lines.append('    length = math.sqrt(dx * dx + dy * dy)')
        lines.append('    ')
        lines.append('    if length == 0:')
        lines.append('        return')
        lines.append('    ')
        lines.append('    dx /= length')
        lines.append('    dy /= length')
        lines.append('    ')
        lines.append('    num_dots = int(length / dot_spacing)')
        lines.append('    ')
        lines.append('    for i in range(num_dots + 1):')
        lines.append('        x = int(x1 + dx * dot_spacing * i)')
        lines.append('        y = int(y1 + dy * dot_spacing * i)')
        lines.append('        cv2.circle(frame, (x, y), thickness, color, -1, cv2.LINE_AA)')
        lines.append('')
        lines.append('def draw_dashed_polyline(frame, points, color, thickness=1, dash_length=10):')
        lines.append('    """Малювання пунктирної лінії вздовж polyline (кожен штрих — пряма)"""')
        lines.append('    if len(points) < 2 or dash_length <= 0:')
        lines.append('        return')
        lines.append('    ')
        lines.append('    total_length = polyline_length(points)')
        lines.append('    if total_length <= 0:')
        lines.append('        return')
        lines.append('    ')
        lines.append('    current = 0.0')
        lines.append('    draw_segment = True')
        lines.append('    ')
        lines.append('    while current < total_length:')
        lines.append('        next_dist = min(current + dash_length, total_length)')
        lines.append('        if draw_segment:')
        lines.append('            start_pt = point_on_polyline(points, current)')
        lines.append('            end_pt = point_on_polyline(points, next_dist)')
        lines.append('            if start_pt and end_pt:')
        lines.append('                x1, y1 = int(round(start_pt[0])), int(round(start_pt[1]))')
        lines.append('                x2, y2 = int(round(end_pt[0])), int(round(end_pt[1]))')
        lines.append('                if x1 != x2 or y1 != y2:')
        lines.append('                    cv2.line(frame, (x1, y1), (x2, y2), color, thickness, cv2.LINE_AA)')
        lines.append('                else:')
        lines.append('                    cv2.circle(frame, (x1, y1), max(1, thickness), color, -1, cv2.LINE_AA)')
        lines.append('        current = next_dist')
        lines.append('        draw_segment = not draw_segment')
        lines.append('')
        lines.append('def draw_dotted_polyline(frame, points, color, thickness=1, dot_spacing=5):')
        lines.append('    """Малювання точок вздовж polyline з рівним кроком"""')
        lines.append('    if len(points) < 2 or dot_spacing <= 0:')
        lines.append('        return')
        lines.append('    ')
        lines.append('    total_length = polyline_length(points)')
        lines.append('    if total_length <= 0:')
        lines.append('        return')
        lines.append('    ')
        lines.append('    dist = 0.0')
        lines.append('    while dist <= total_length:')
        lines.append('        pt = point_on_polyline(points, dist)')
        lines.append('        if pt:')
        lines.append('            x, y = int(round(pt[0])), int(round(pt[1]))')
        lines.append('            cv2.circle(frame, (x, y), max(1, thickness), color, -1, cv2.LINE_AA)')
        lines.append('        dist += dot_spacing')
        lines.append('    ')
        lines.append('    pt_end = point_on_polyline(points, total_length)')
        lines.append('    if pt_end:')
        lines.append('        x, y = int(round(pt_end[0])), int(round(pt_end[1]))')
        lines.append('        cv2.circle(frame, (x, y), max(1, thickness), color, -1, cv2.LINE_AA)')
        lines.append('')
        lines.append('def polyline_length(points):')
        lines.append('    """Обчислити довжину polyline"""')
        lines.append('    total = 0.0')
        lines.append('    for i in range(len(points) - 1):')
        lines.append('        total += math.hypot(points[i + 1][0] - points[i][0], points[i + 1][1] - points[i][1])')
        lines.append('    return total')
        lines.append('')
        lines.append('def point_on_polyline(points, target_dist):')
        lines.append('    """Отримати точку polyline на заданій відстані"""')
        lines.append('    if not points:')
        lines.append('        return None')
        lines.append('    ')
        lines.append('    if target_dist <= 0:')
        lines.append('        return points[0]')
        lines.append('    ')
        lines.append('    travelled = 0.0')
        lines.append('    for i in range(len(points) - 1):')
        lines.append('        pt1 = points[i]')
        lines.append('        pt2 = points[i + 1]')
        lines.append('        segment = math.hypot(pt2[0] - pt1[0], pt2[1] - pt1[1])')
        lines.append('        if segment == 0:')
        lines.append('            continue')
        lines.append('        if travelled + segment >= target_dist:')
        lines.append('            t = (target_dist - travelled) / segment')
        lines.append('            x = pt1[0] + (pt2[0] - pt1[0]) * t')
        lines.append('            y = pt1[1] + (pt2[1] - pt1[1]) * t')
        lines.append('            return (x, y)')
        lines.append('        travelled += segment')
        lines.append('    return points[-1]')
        lines.append('')
        lines.append('def draw_bezier_curve(frame, x1, y1, x2, y2, cx, cy, color, thickness=1, steps=20):')
        lines.append('    """Малювання квадратичної кривої Безьє"""')
        lines.append('    points = []')
        lines.append('    for i in range(steps + 1):')
        lines.append('        t = i / steps')
        lines.append('        bx = int((1 - t) ** 2 * x1 + 2 * (1 - t) * t * cx + t ** 2 * x2)')
        lines.append('        by = int((1 - t) ** 2 * y1 + 2 * (1 - t) * t * cy + t ** 2 * y2)')
        lines.append('        points.append([bx, by])')
        lines.append('    pts = np.array([points], dtype=np.int32)')
        lines.append('    cv2.polylines(frame, pts, False, color, thickness, cv2.LINE_AA)')
        lines.append('')
        lines.append('def draw_cubic_bezier_curve(frame, x1, y1, x2, y2, cx1, cy1, cx2, cy2, color, thickness=1, steps=50):')
        lines.append('    """Малювання кубічної кривої Безьє"""')
        lines.append('    points = []')
        lines.append('    for i in range(steps + 1):')
        lines.append('        t = i / steps')
        lines.append('        bx = int((1-t)**3*x1 + 3*(1-t)**2*t*cx1 + 3*(1-t)*t**2*cx2 + t**3*x2)')
        lines.append('        by = int((1-t)**3*y1 + 3*(1-t)**2*t*cy1 + 3*(1-t)*t**2*cy2 + t**3*y2)')
        lines.append('        points.append([bx, by])')
        lines.append('    pts = np.array([points], dtype=np.int32)')
        lines.append('    cv2.polylines(frame, pts, False, color, thickness, cv2.LINE_AA)')
        lines.append('')
        lines.append('def calculate_bezier_points(x1, y1, x2, y2, cx, cy, num_points=50):')
        lines.append('    """Розрахувати точки квадратичної кривої Безьє"""')
        lines.append('    points = []')
        lines.append('    for i in range(num_points + 1):')
        lines.append('        t = i / num_points')
        lines.append('        x = (1 - t) ** 2 * x1 + 2 * (1 - t) * t * cx + t ** 2 * x2')
        lines.append('        y = (1 - t) ** 2 * y1 + 2 * (1 - t) * t * cy + t ** 2 * y2')
        lines.append('        points.append((int(x), int(y)))')
        lines.append('    return points')
        lines.append('')
        lines.append('def calculate_cubic_bezier_points(x1, y1, x2, y2, cx1, cy1, cx2, cy2, num_points=50):')
        lines.append('    """Розрахувати точки кубічної кривої Безьє"""')
        lines.append('    points = []')
        lines.append('    for i in range(num_points + 1):')
        lines.append('        t = i / num_points')
        lines.append('        t_inv = 1 - t')
        lines.append('        x = t_inv ** 3 * x1 + 3 * t_inv ** 2 * t * cx1 + 3 * t_inv * t ** 2 * cx2 + t ** 3 * x2')
        lines.append('        y = t_inv ** 3 * y1 + 3 * t_inv ** 2 * t * cy1 + 3 * t_inv * t ** 2 * cy2 + t ** 3 * y2')
        lines.append('        points.append((int(x), int(y)))')
        lines.append('    return points')
        lines.append('')
        lines.append('')
        
        # Якщо є групи, генеруємо класи для кожної групи
        if groups and len(groups) > 0:
            # Збираємо фігури по групах
            group_shapes = {}
            for group in groups:
                group_shapes[group.name] = []
                for idx in group.shape_indices:
                    if 0 <= idx < len(shapes):
                        group_shapes[group.name].append((idx, shapes[idx]))
            
            # Генеруємо класи для груп
            for group in groups:
                group_name = group.name
                group_shapes_list = group_shapes.get(group_name, [])
                
                if not group_shapes_list:
                    continue
                
                # Збираємо унікальні кольори
                colors = {}
                color_counter = 0
                color_names = ['red', 'blue', 'green', 'yellow', 'cyan', 'magenta', 'white', 'black']
                
                lines.append(f'class {CodeGenerator._sanitize_class_name(group_name)}:')
                lines.append('    """')
                lines.append(f'    Клас для малювання групи: {group_name}')
                coord_system = 'як у редакторі (0,0 в лівому верхньому куті)' if origin_mode == 'editor' else 'як у OpenCV (0,0 в лівому верхньому куті)'
                lines.append(f'    Система координат: {coord_system}')
                lines.append(f'    Кількість фігур: {len(group_shapes_list)}')
                lines.append('    """')
                lines.append('    ')
                lines.append('    def __init__(self):')
                lines.append('        """Ініціалізація кольорів"""')
                lines.append('        self.colors = {')
                
                # Збираємо кольори
                for idx, shape in group_shapes_list:
                    color_tuple = shape.color_bgr
                    color_key = None
                    for key, val in colors.items():
                        if val == color_tuple:
                            color_key = key
                            break
                    if color_key is None:
                        color_key = color_names[color_counter % len(color_names)]
                        colors[color_key] = color_tuple
                        color_counter += 1
                
                for color_name, color_tuple in colors.items():
                    lines.append(f"            '{color_name}': {color_tuple},")
                lines.append('        }')
                lines.append('    ')
                lines.append('    def draw(self, frame):')
                lines.append('        """Намалювати фігури на кадрі"""')
                
                # Генеруємо код для кожної фігури в групі
                for idx, shape in group_shapes_list:
                    color_tuple = shape.color_bgr
                    color_key = None
                    for key, val in colors.items():
                        if val == color_tuple:
                            color_key = key
                            break
                    
                    shape_code = CodeGenerator._generate_shape_code(shape, color_key, origin_mode, canvas_width, canvas_height)
                    lines.extend(shape_code)
                
                lines.append('        return frame')
                lines.append('')
                lines.append('')
            
            # Генеруємо приклад використання
            lines.append('# Приклад використання:')
            lines.append('if __name__ == \'__main__\':')
            lines.append('    # Читаємо або створюємо кадр')
            if canvas_width and canvas_height:
                lines.append(f'    frame = np.zeros(({canvas_height}, {canvas_width}, 3), dtype=np.uint8)  # Чорний кадр')
            else:
                lines.append('    frame = np.zeros((720, 1280, 3), dtype=np.uint8)  # Чорний кадр')
            lines.append('    # або завантажте з відео/камери:')
            lines.append('    # cap = cv2.VideoCapture(0)')
            lines.append('    # ret, frame = cap.read()')
            lines.append('    ')
            lines.append('    # Створюємо екземпляри груп')
            for group in groups:
                class_name = CodeGenerator._sanitize_class_name(group.name)
                var_name = CodeGenerator._sanitize_variable_name(group.name)
                lines.append(f'    {var_name} = {class_name}()')
            lines.append('    ')
            lines.append('    # Малюємо всі групи')
            for group in groups:
                var_name = CodeGenerator._sanitize_variable_name(group.name)
                lines.append(f'    frame = {var_name}.draw(frame)')
            lines.append('    ')
            lines.append('    # Показуємо результат')
            lines.append('    cv2.imshow(\'Overlay\', frame)')
            lines.append('    cv2.waitKey(0)')
            lines.append('    cv2.destroyAllWindows()')
        else:
            # Якщо немає груп, генеруємо простий код без класів
            lines.append('def draw_overlay(frame):')
            lines.append('    """Намалювати всі фігури на кадрі"""')
            
            for shape in shapes:
                shape_code = CodeGenerator._generate_shape_code(shape, None, origin_mode, canvas_width, canvas_height)
                lines.extend(shape_code)
            
            lines.append('    return frame')
            lines.append('')
            lines.append('')
            lines.append('# Приклад використання:')
            lines.append('if __name__ == \'__main__\':')
            lines.append('    # Читаємо або створюємо кадр')
            if canvas_width and canvas_height:
                lines.append(f'    frame = np.zeros(({canvas_height}, {canvas_width}, 3), dtype=np.uint8)  # Чорний кадр')
            else:
                lines.append('    frame = np.zeros((720, 1280, 3), dtype=np.uint8)  # Чорний кадр')
            lines.append('    # або завантажте з відео/камери:')
            lines.append('    # cap = cv2.VideoCapture(0)')
            lines.append('    # ret, frame = cap.read()')
            lines.append('    ')
            lines.append('    # Малюємо overlay')
            lines.append('    frame = draw_overlay(frame)')
            lines.append('    ')
            lines.append('    # Показуємо результат')
            lines.append('    cv2.imshow(\'Overlay\', frame)')
            lines.append('    cv2.waitKey(0)')
            lines.append('    cv2.destroyAllWindows()')
        
        return '\n'.join(lines)
    
    @staticmethod
    def _sanitize_class_name(name):
        """Перетворити назву в валідну назву класу Python"""
        # Видаляємо спеціальні символи та замінюємо пробіли
        name = ''.join(c if c.isalnum() or c == '_' else '_' for c in name)
        # Перша літера має бути великою
        if name and name[0].islower():
            name = name[0].upper() + name[1:]
        # Якщо назва порожня або починається з цифри
        if not name or name[0].isdigit():
            name = 'Group_' + name
        return name
    
    @staticmethod
    def _sanitize_variable_name(name):
        """Перетворити назву в валідну назву змінної Python"""
        # Видаляємо спеціальні символи та замінюємо пробіли
        name = ''.join(c if c.isalnum() or c == '_' else '_' for c in name)
        # Перша літера має бути малою
        if name and name[0].isupper():
            name = name[0].lower() + name[1:]
        # Якщо назва порожня або починається з цифри
        if not name or name[0].isdigit():
            name = 'group_' + name
        return name
    
    @staticmethod
    def _generate_shape_code(shape, color_key, origin_mode, canvas_width, canvas_height):
        """Генерувати код для однієї фігури"""
        lines = []
        indent = '        '
        
        # Конвертуємо координати якщо потрібно
        def convert_coords(coords_dict):
            result = {}
            for key, value in coords_dict.items():
                if isinstance(value, (int, float)):
                    if origin_mode == 'opencv' and canvas_height:
                        # Конвертуємо Y координату
                        if key.startswith('y') or key == 'cy':
                            result[key] = canvas_height - value
                        else:
                            result[key] = value
                    else:
                        result[key] = value
                elif isinstance(value, (list, tuple)):
                    if origin_mode == 'opencv' and canvas_height:
                        # Конвертуємо Y координати в списках точок
                        converted = []
                        for item in value:
                            if isinstance(item, (list, tuple)) and len(item) >= 2:
                                converted.append([item[0], canvas_height - item[1]])
                            else:
                                converted.append(item)
                        result[key] = converted
                    else:
                        result[key] = value
                else:
                    result[key] = value
            return result
        
        coords = convert_coords(shape.coords)
        
        # Формуємо колір
        if color_key:
            color_str = f"self.colors['{color_key}']"
        else:
            color_str = str(shape.color_bgr)
        
        # Отримуємо стиль лінії з безпечною перевіркою
        line_style = getattr(shape, 'line_style', 'solid')
        dash_length = getattr(shape, 'dash_length', 10)
        dot_length = getattr(shape, 'dot_length', 5)
        
        # Генеруємо код залежно від типу фігури
        if shape.kind == 'line':
            x1, y1 = int(coords['x1']), int(coords['y1'])
            x2, y2 = int(coords['x2']), int(coords['y2'])
            
            if line_style == 'solid':
                lines.append(f'{indent}cv2.line(frame, ({x1}, {y1}), ({x2}, {y2}), {color_str}, {shape.thickness}, cv2.LINE_AA)')
            elif line_style == 'dashed':
                lines.append(f'{indent}draw_dashed_line(frame, ({x1}, {y1}), ({x2}, {y2}), {color_str}, {shape.thickness}, {dash_length})')
            elif line_style == 'dotted':
                lines.append(f'{indent}draw_dotted_line(frame, ({x1}, {y1}), ({x2}, {y2}), {color_str}, {shape.thickness}, {dot_length})')
            else:
                # За замовчуванням суцільна лінія
                lines.append(f'{indent}cv2.line(frame, ({x1}, {y1}), ({x2}, {y2}), {color_str}, {shape.thickness}, cv2.LINE_AA)')
        
        elif shape.kind == 'circle':
            cx, cy = int(coords['cx']), int(coords['cy'])
            radius = int(coords.get('radius', coords.get('r', 10)))
            fill = -1 if shape.filled else shape.thickness
            lines.append(f'{indent}cv2.circle(frame, ({cx}, {cy}), {radius}, {color_str}, {fill}, cv2.LINE_AA)')
        
        elif shape.kind == 'rectangle':
            x1, y1 = int(coords['x1']), int(coords['y1'])
            x2, y2 = int(coords['x2']), int(coords['y2'])
            fill = -1 if shape.filled else shape.thickness
            lines.append(f'{indent}cv2.rectangle(frame, ({x1}, {y1}), ({x2}, {y2}), {color_str}, {fill}, cv2.LINE_AA)')
        
        elif shape.kind == 'text':
            x, y = int(coords['x']), int(coords['y'])
            text = shape.text.replace("'", "\\'").replace('"', '\\"')
            font_scale = shape.font_scale
            lines.append(f'{indent}cv2.putText(frame, \'{text}\', ({x}, {y}), cv2.FONT_HERSHEY_SIMPLEX, {font_scale}, {color_str}, {shape.thickness}, cv2.LINE_AA)')
        
        elif shape.kind == 'point':
            x, y = int(coords['x']), int(coords['y'])
            lines.append(f'{indent}cv2.circle(frame, ({x}, {y}), {shape.thickness}, {color_str}, -1, cv2.LINE_AA)')
        
        elif shape.kind == 'polygon':
            points = coords.get('points', [])
            if points:
                pts_str = ', '.join([f'[{int(p[0])}, {int(p[1])}]' for p in points])
                if shape.filled:
                    lines.append(f'{indent}pts = np.array([{pts_str}], dtype=np.int32)')
                    lines.append(f'{indent}pts = pts.reshape((-1, 1, 2))')
                    lines.append(f'{indent}cv2.fillPoly(frame, [pts], {color_str}, cv2.LINE_AA)')
                else:
                    lines.append(f'{indent}pts = np.array([{pts_str}], dtype=np.int32)')
                    lines.append(f'{indent}pts = pts.reshape((-1, 1, 2))')
                    lines.append(f'{indent}cv2.polylines(frame, [pts], True, {color_str}, {shape.thickness}, cv2.LINE_AA)')
        
        elif shape.kind == 'arrow':
            x1, y1 = int(coords['x1']), int(coords['y1'])
            x2, y2 = int(coords['x2']), int(coords['y2'])
            
            if line_style == 'solid':
                lines.append(f'{indent}cv2.arrowedLine(frame, ({x1}, {y1}), ({x2}, {y2}), {color_str}, {shape.thickness}, cv2.LINE_AA, tipLength=0.3)')
            elif line_style == 'dashed':
                lines.append(f'{indent}draw_dashed_line(frame, ({x1}, {y1}), ({x2}, {y2}), {color_str}, {shape.thickness}, {dash_length})')
            elif line_style == 'dotted':
                lines.append(f'{indent}draw_dotted_line(frame, ({x1}, {y1}), ({x2}, {y2}), {color_str}, {shape.thickness}, {dot_length})')
            else:
                # За замовчуванням суцільна стрілка
                lines.append(f'{indent}cv2.arrowedLine(frame, ({x1}, {y1}), ({x2}, {y2}), {color_str}, {shape.thickness}, cv2.LINE_AA, tipLength=0.3)')
        
        elif shape.kind == 'ellipse':
            cx, cy = int(coords['cx']), int(coords['cy'])
            rx, ry = int(coords['rx']), int(coords['ry'])
            angle = int(coords.get('angle', 0))
            fill = -1 if shape.filled else shape.thickness
            lines.append(f'{indent}cv2.ellipse(frame, ({cx}, {cy}), ({rx}, {ry}), {angle}, 0, 360, {color_str}, {fill}, cv2.LINE_AA)')
        
        elif shape.kind == 'curve':
            # Квадратична крива Безьє
            x1, y1 = int(coords['x1']), int(coords['y1'])
            x2, y2 = int(coords['x2']), int(coords['y2'])
            cx, cy = int(coords['cx']), int(coords['cy'])
            steps = CodeGenerator._estimate_curve_steps(coords)
            
            if line_style == 'solid':
                lines.append(f'{indent}draw_bezier_curve(frame, {x1}, {y1}, {x2}, {y2}, {cx}, {cy}, {color_str}, {shape.thickness}, {steps})')
            elif line_style == 'dashed':
                # Для пунктирних кривих обчислюємо точки та малюємо пунктир вздовж polyline
                lines.append(f'{indent}bezier_points = calculate_bezier_points({x1}, {y1}, {x2}, {y2}, {cx}, {cy}, {steps})')
                lines.append(f'{indent}draw_dashed_polyline(frame, bezier_points, {color_str}, {shape.thickness}, {dash_length})')
            elif line_style == 'dotted':
                # Для точкових кривих обчислюємо точки та малюємо polyline точками
                lines.append(f'{indent}bezier_points = calculate_bezier_points({x1}, {y1}, {x2}, {y2}, {cx}, {cy}, {steps})')
                lines.append(f'{indent}draw_dotted_polyline(frame, bezier_points, {color_str}, {shape.thickness}, {dot_length})')
            else:
                # За замовчуванням суцільна крива
                lines.append(f'{indent}draw_bezier_curve(frame, {x1}, {y1}, {x2}, {y2}, {cx}, {cy}, {color_str}, {shape.thickness}, {steps})')
        
        elif shape.kind == 'cubic_curve':
            # Кубічна крива Безьє
            x1, y1 = int(coords['x1']), int(coords['y1'])
            x2, y2 = int(coords['x2']), int(coords['y2'])
            cx1, cy1 = int(coords['cx1']), int(coords['cy1'])
            cx2, cy2 = int(coords['cx2']), int(coords['cy2'])
            steps = CodeGenerator._estimate_curve_steps(coords, cubic=True)
            
            if line_style == 'solid':
                lines.append(f'{indent}draw_cubic_bezier_curve(frame, {x1}, {y1}, {x2}, {y2}, {cx1}, {cy1}, {cx2}, {cy2}, {color_str}, {shape.thickness}, {steps})')
            elif line_style == 'dashed':
                # Для пунктирних кривих використовуємо polyline з урахуванням довжини
                lines.append(f'{indent}bezier_points = calculate_cubic_bezier_points({x1}, {y1}, {x2}, {y2}, {cx1}, {cy1}, {cx2}, {cy2}, {steps})')
                lines.append(f'{indent}draw_dashed_polyline(frame, bezier_points, {color_str}, {shape.thickness}, {dash_length})')
            elif line_style == 'dotted':
                # Для точкових кривих використовуємо polyline з урахуванням довжини
                lines.append(f'{indent}bezier_points = calculate_cubic_bezier_points({x1}, {y1}, {x2}, {y2}, {cx1}, {cy1}, {cx2}, {cy2}, {steps})')
                lines.append(f'{indent}draw_dotted_polyline(frame, bezier_points, {color_str}, {shape.thickness}, {dot_length})')
            else:
                # За замовчуванням суцільна крива
                lines.append(f'{indent}draw_cubic_bezier_curve(frame, {x1}, {y1}, {x2}, {y2}, {cx1}, {cy1}, {cx2}, {cy2}, {color_str}, {shape.thickness}, {steps})')
        
        return lines

    @staticmethod
    def _estimate_curve_steps(coords, cubic=False):
        """Оцінити кількість сегментів для кривої для кращої якості"""
        def dist(pt_a, pt_b):
            return math.hypot(pt_a[0] - pt_b[0], pt_a[1] - pt_b[1])
        
        if cubic:
            p0 = (coords['x1'], coords['y1'])
            p1 = (coords['cx1'], coords['cy1'])
            p2 = (coords['cx2'], coords['cy2'])
            p3 = (coords['x2'], coords['y2'])
            approx_len = dist(p0, p1) + dist(p1, p2) + dist(p2, p3)
        else:
            p0 = (coords['x1'], coords['y1'])
            p1 = (coords['cx'], coords['cy'])
            p2 = (coords['x2'], coords['y2'])
            approx_len = dist(p0, p1) + dist(p1, p2)
        
        approx_len += dist((coords['x1'], coords['y1']), (coords['x2'], coords['y2']))
        steps = int(max(60, min(400, approx_len / 3)))
        return steps
